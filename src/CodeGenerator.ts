import CodeGeneratorProps from "./CodeGeneratorType";
class CodeGenerator {
  public info = `// Random Hydra code generated by HCG: https://github.com/alecominotti/hydracodegenerator/\n// @alecominotti\n\n`;
  public minValue = 0; // lower bound value to set as function argument,
  public maxValue = 5; // upper bound value to set as function argument,
  public arrowFunctionProb = 10; // Probabilities of generating an arrow function that changes value over time (ex.: () => Math.sin(time * 0.3)),
  public mouseFunctionProb = 0; // Probabilities of generating an arrow function that uses mouse position (ex.: () => mouse.x),
  public modulateItselfProb = 20; // Probabilities of generating a modulation function with "o0" as argument (ex.: modulate(o0,1)),
  public mathFunctions = ["sin", "cos", "tan"];
  public mouseList = ["mouse.x", "mouse.y"];
  public sourcesList = [
    "gradient",
    "noise",
    "osc",
    "shape",
    "solid",
    "voronoi",
  ];
  public colorList = [
    "brightness",
    "contrast",
    "color",
    "colorama",
    "invert",
    "luma",
    "posterize",
    "saturate",
    "thresh",
  ];
  public geometryList = [
    "kaleid",
    "pixelate",
    "repeat",
    "repeatX",
    "repeatY",
    "rotate",
    "scale",
    "scrollX",
    "scrollY",
  ];
  public modulatorsList = [
    "modulate",
    "modulateHue",
    "modulateKaleid",
    "modulatePixelate",
    "modulateRepeat",
    "modulateRepeatX",
    "modulateRepeatY",
    "modulateRotate",
    "modulateScale",
    "modulateScrollX",
    "modulateScrollY",
  ];
  public operatorsList = ["add", "blend", "diff", "layer", "mask", "mult"];
  public functionsList = [
    "genColor",
    "genGeometry",
    "genModulator",
    "genOperator",
  ];
  public ignoredList = [
    "solid",
    "brightness",
    "luma",
    "invert",
    "posterize",
    "thresh",
    "layer",
    "modulateScrollX",
    "modulateScrollY",
  ];
  public exclusiveSourceList = [];
  public exclusiveFunctionList = [];
  constructor({
    min = 0,
    max = 5,
    arrowFunctionProb = 10,
    mouseFunctionProb = 0,
    modulateItselfProb = 20,
    ignoredList = [],
    exclusiveSourceList = [],
    exclusiveFunctionList = [],
  }: CodeGeneratorProps) {
    if (!min) this.minValue = min;
    if (!max) this.maxValue = max;
    if (!min && !max && min > max) {
      this.printError("Argument max value must be bigger than min value.");
      return;
    }
    if (!ignoredList && ignoredList.length) this.ignoredList = ignoredList;
    if (!arrowFunctionProb)
      if (0 <= arrowFunctionProb && arrowFunctionProb <= 100)
        this.arrowFunctionProb = arrowFunctionProb;
      else {
        this.printError(
          "Arrow function probability must be a number between 0 and 100."
        );
        return;
      }
    if (!mouseFunctionProb)
      if (0 <= mouseFunctionProb && mouseFunctionProb <= 100)
        this.mouseFunctionProb = mouseFunctionProb;
      else {
        this.printError(
          "Mouse arrow function probability must be a number between 0 and 100."
        );
        return;
      }
    if (!modulateItselfProb)
      if (0 <= modulateItselfProb && modulateItselfProb <= 100)
        this.modulateItselfProb = modulateItselfProb;
      else {
        this.printError(
          "Modulate itself probability must be a number between 0 and 100."
        );
        return;
      }
    if (!exclusiveSourceList && exclusiveSourceList.length > 0)
      if (this.checkSources(exclusiveSourceList))
        this.exclusiveSourceList = exclusiveSourceList;
      else if (!exclusiveSourceList.length) {
        this.printError(
          "One or more of the specified exclusive sources doesn't exist"
        );
        return;
      }
    if (!exclusiveFunctionList && exclusiveFunctionList.length > 0)
      if (this.checkFunctions(exclusiveFunctionList))
        this.exclusiveFunctionList = exclusiveFunctionList;
      else if (!exclusiveFunctionList.length) {
        this.printError(
          "One or more of the specified exclusive functions don't exist"
        );
        return;
      }
    if (
      ignoredList.length > 0 &&
      (exclusiveSourceList.length > 0 || exclusiveFunctionList.length > 0)
    ) {
      const exclusiveSourceAndFunction = [
        ...this.exclusiveSourceList,
        ...this.exclusiveFunctionList,
      ];
      const isExclusiveIgnored = exclusiveSourceAndFunction.some(
        (functionName) => this.ignoredList.includes(functionName)
      );
      // if( len([i for i in exclusiveSourceAndFunction if i in this.ignoredList]) > 0)
      if (isExclusiveIgnored)
        this.printError(
          "You can't ignore sources or functions specified as exclusive"
        );
      return;
    }
  }
  printError(msg) {
    console.log(msg);
  }
  checkSources(sources: string[]) {
    console.log("sources: ", sources);
    return isSubset(sources, this.sourcesList);
  }
  checkFunctions(functions: string[]) {
    console.log("functions: ", functions);
    const allFunctions = [
      ...this.colorList,
      ...this.geometryList,
      ...this.modulatorsList,
      ...this.operatorsList,
    ];
    return isSubset(functions, allFunctions);
  }
  truncate(number: number, digits: number): number {
    const stepper = 10.0 ** digits;
    return Math.trunc(stepper * number) / stepper;
  }

  isIgnored(chosen: string) {
    return this.ignoredList.includes(chosen);
  }
  isExclusiveSource(chosen: string) {
    if (this.exclusiveSourceList.length === 0) {
      return true;
    } else {
      return this.exclusiveSourceList.includes(chosen);
    }
  }

  isExclusiveFunction(chosen: string) {
    if (this.exclusiveFunctionList.length == 0) {
      return true;
    } else {
      return this.exclusiveFunctionList.includes(chosen);
      // return(chosen.lower() in [x.lower() for x in this.exclusiveFunctionList])
    }
  }
  genNormalValue() {
    const randomTruncate = random.randint(0, 3);
    const val = this.truncate(
      random.uniform(this.minValue, this.maxValue),
      randomTruncate
    );
    return val.toString();
  }
  genArrowFunctionValue() {
    const randomTimeMultiplier = this.truncate(
      random.uniform(0.1, 1),
      random.randint(1, 2)
    );
    //probabilities of generating an arrow function
    if (random.randint(1, 100) <= this.arrowFunctionProb) {
      const arrowFunctionName =
        this.mathFunctions[random.randint(0, this.mathFunctions.length - 1)];
      return `() => Math.${arrowFunctionName}(time * ${randomTimeMultiplier})`;
    }
    //probabilities of generating a mouse function
    if (random.randint(1, 100) <= this.mouseFunctionProb) {
      return `() =>  ${
        this.mouseList[random.randint(0, this.mouseList.length - 1)]
      }  * ${randomTimeMultiplier}`;
    }
    return "";
  }
  //generates a number, mouse, or math functions
  genValue() {
    const arrow = this.genArrowFunctionValue();
    if (arrow !== "") return arrow;
    else return this.genNormalValue();
  }
  // generates a normal number with 1/5 posibilities of being negative
  genPosOrNegValue() {
    const arrow = this.genArrowFunctionValue();
    if (arrow != "") return arrow;
    else if (random.randint(1, 5) == 5) return "-" + this.genNormalValue();
    else return this.genNormalValue();
  }
  //generates a number between 0 and 1
  genCeroOneValue() {
    const arrow = this.genArrowFunctionValue();
    if (arrow !== "") return arrow;
    else return this.truncate(random.uniform(0, 1), 1).toString();
  }
  // generates a number between 0 and 0.5
  genCeroPointFiveValue() {
    const arrow = this.genArrowFunctionValue();
    if (arrow != "") return arrow;
    else return this.truncate(random.uniform(0, 0.5), 2).toString();
  }
  //generates a number between 0.1 and maxValue
  genCeroPointOneToMax() {
    const arrow = this.genArrowFunctionValue();
    if (arrow !== "") return arrow;
    else return this.truncate(random.uniform(0.1, this.maxValue), 2).toString();
  }
  //generates a number between 0.1 and maxValue
  genCeroPointOneToOne() {
    const arrow = this.genArrowFunctionValue();
    if (arrow != "") return arrow;
    else return str(this.truncate(random.uniform(0.1, 1), 2));
  }
  // END VALUE GENERATION METHODS ---

  // MAIN METHODS ---
  /*
  generateCode(minFunctions, maxFunctions) {
    const functionsAmount = random.randint(minFunctions, maxFunctions);
    let code = "";
    code += this.info;
    code += this.genSource() + "\n";
    Array(functionsAmount)
      .fill("")
      .forEach((_) => {
        code += "  " + this.genFunction() + "\n";
        code += ".out(o0)";
      });
    return code;
  }
  */
  /**
   * returns a source calling one of them randomly
   */
  /*
  genSource(){

      const fullSource = operator.methodcaller(random.choice((this.sourcesList)))(this);
      const source=fullSource.split("(")[0] // just source name
      const start = time.time() // avoids failing when everything is ignored
      while((!this.isExclusiveSource(source))|| this.isIgnored(source) && (time.time() < (start + 10))){}
      fullSource = operator.methodcaller(random.choice((this.sourcesList)))(this)
      source=fullSource.split("(")[0]
      if(time.time() >= (start + 15)):
      this.printError("Could't generate a Source (You ignored all of them")
      return
      else:
      return fullSource
    }
    */
}

/*javascript function that checks if a given set is a subset of another given one*/
function isSubset(set: Array<string>, superSet: Array<string>) {
  for (var i = 0; i < set.length; i++) {
    if (superSet.indexOf(set[i]) === -1) {
      return false;
    }
  }
  return true;
}
class random {
  static randint(min: number, max: number) {
    return Math.floor(Math.random() * (max - min)) + min;
  }
  static uniform(min: number, max: number) {
    return Math.random() * (max - min) + min;
  }
  static choice(list: Array<any>) {
    var index = Math.floor(Math.random() * list.length);
    return list[index];
  }
}
export default CodeGenerator;
